# 列表和元组
Python包含6种内建的序列，包括本章要讲的列表（list），元组（tuple），还有之前提到过的字符串以及Unicode字符串，buffer对象和xrange对象。  
列表和元组的主要区别在于：列表可以修改而元组不能。列表相当于一个容器，可以包含若干个元素，元素的类型不限，元素之间用逗号隔开，列表整体用方括号表示。
``` python
classmates = ['Michael', 'Bob', 'Tracy']
```
上面为一个包含三个元素的列表，这个列表包含三个字符串。

- 建立列表  
你可以直接声明一个列表，像上文那样，也可以调用list函数，该函数可以根据字符串创建一个列表。
``` python
>>>list('Hello')
['H','e','l','l','o']
```
- 元素赋值
用索引来访问list中每一个位置的元素，记得索引是从0开始的
``` python
>>> x = [1,1,1]
>>> x[1] = 2   
>>> x
[1,2,1]
```
使用使用负数索引时，Python会从右边，也就是最后一个元素开始，注意最后一个元素的位置编号是-1，不是-0，因为那会和第一个元素重合。
``` python
>>> x = [1,1,1]
>>> x[-1] = 2   
>>> x
[1,1,2]
```
- 删除元素  
使用del语句实现
``` python
>>>names = ['alice','beth','cecil','ian','frank']
>>>del names[2]
>>>names
['alice','beth','ian','frank']
```
- 分片  
分片是对序列中一定范围的元素同时访问的操作。分片通过冒号隔开的两个索引实现。分片操作对于提取序列的一部分有用的，而编号在这里尤为重要。第一个索引是要提取的第一个元素的编号，而最后的索引则是分片之后剩余部分的第一个元素的编号。参加下面的代码
``` python
>>> name = list ('Perl')
>>> name
['P','e','r','l']
>>> del name[1:3]
>>> name
['P','l']
```
置空最后一个索引可以包括后面的所有元素。
``` python
>>> name = list ('Perl')
>>> name
['P','e','r','l']
>>> del name[1:]
>>> name
['P']
```
- 列表方法  
方法是一个与某些对象与紧密联系的函数，对象可能是列表，数字，也可能是字符串或者其他类型的对象，一般来说，方法可以这样调用：  
   对象.方法（参数）  
除了对象被放置到方法名之前，并且两者之间用一个点号隔开，方法调用与函数调用很类似。
1. append  
用于在列表末尾追加新的对象
```python
>>> prise = [1,2,3]
>>> prise.append(4)
>>> prise
[1,2,3,4]
```
2. count  
count方法统计某个元素在列表中出现的次数：
``` python
>>> ['to','be','or','not','to','be'].count('to')
2
>>> x = [[1,2],1,1,[2,1,[1,2]]]
>>> x.count(1)
2
>>> x.coout([1.2])
1
```
3. extend
extend方法可以在列表的末尾一次性追加另一个序列中的多个值。换句话来说，可以用新列表来扩展原有的列表：
``` python
>>> a = [1,2,3]
>>> b = [4,5,6]
>>> a.extend(b)
>>> a 
[1,2,3,4,5,6]
```
4. index
index方法用于从列表中找出某个值第一个匹配项的索引位置
``` python
>>> word = ['long','long','ago','there','is','a','swag','chigga']
>>> word.index('swag')
6
```
5. insert
insert方法用于将对象插入到列表中
``` python
>>> word = ['long','long','ago','there','was','a','swag','chigga']
>>> word.insert(5,'young')
>>> word
['long', 'long', 'ago', 'there', 'was', 'young', 'a', 'swag', 'chigga']
```
6. pop
pop函数会移除列表中的一个元素，（默认是最后一个），并且返回该元素的值
``` python
>>> word = ['long', 'long', 'ago', 'there', 'was', 'young', 'a', 'swag', 'chigga']
>>> word.pop()
'chigga'
```
7. reverse  
reverse方法将列表中的函数反向存放
``` python
>>> x = [1,2,3]
>>> x.reverse()
>>> x
[3,2,1]
```
# 字符串
前面提到过列表里的索引，分片，乘法等操作，字符串也可以使用。但是字符串不能改变，故不能索引赋值等操作。
``` python
>>> name = 'ianclock'
>>> name[4]
'l'
>>> name[4] = 'd'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
>>> num = '0123456789'
>>> num[3:6]
'345'
```
- 字符串格式化  
在%的左侧放置一个字符串，右侧放置希望被格式化的值，可以使用一个值，比如一个字符串或者数字,可以是多个值的元组或者之后提到的字典。
``` python
>>> format = 'hello,%s.%s enough for ya?'
>>> values = ('world','Hot')
>>> print (format % values)
```
上例中%右边的s被称作右操作数，如果右操作数是s，则该格式化为字符串类型，当然，不止可以格式化为字符串类型，还可以格式化为整数，浮点数等等。下面通过表格列出一些常用字符串格式化转换类型：  
|转换类型|含义|  
|------|-----|
|d,i    |带符号的十进制数|
|o      |不带符号的八进制|
|u      |不带符号的十进制|
|x      |不带符号的十六进制|
|e      |科学计数法表示的浮点数（小写）|
|E      |科学计数法表示的浮点数（大写）|
|f,F    |十进制浮点数|
|C      |单字符|
|r      |字符串（使用repr转换任意Python对象）|
|s      |字符串（使用str转换任意Python对象）|
``` python
>>> 'Price of egg: $%d' %42
'Price of egg: $42'
>>> 'Hexadecimal price of eggs: %x' %42
'Hexadecimal price of eggs: 2a'
```
## 字符串方法
下面介绍一些常见的字符串方法
- find
find方法可以在一个较长的字符串中查找子串，并返回子串所在位置的最左端索引，如果没有找到则返回-1,该方法默认返回查找到的第一个字串的位置。
``` python
>>>'Remember only god can judg us.'.find('god')
14
```
另外这个方法还可以选择在某个区间内查找，参数为该区间起始点和结束点
``` python
>>> Dat_Stick = 'Ain\'t noboday give a fuck about a rule'
>>> Dat_Stick.find('a',13,30)
19
```
- join  
join方法是非常重要的方法，用来连接序列中的元素：
``` python 
>>> seq = ['1','2','3','4','5']
>>> '+'.join(seq)
'1+2+3+4+5'
```
- lower
lower方法返回字符串的小写字母版。
``` python
>>> 'WHATS WRONG WITH THE WORLD?'.lower()
'whats wrong with the world?'
```
当然还有upper是返回字符串的大写字母版
- replace
replace方法返回某字符串的所有匹配项均被替换之后得到的字符串
``` python
>>> 'This is a test'.replace('is','eez')
'Theez eez a test'
```
- split  
split方法可以看做是join的逆方法,用来将字符串分隔成列表
``` python
>>> '1+2+3+4+5'.split('+')
['1', '2', '3', '4', '5']
```
# 字典
字典也是Python内建的一种数据类型，字典由多个键以及与其对应的值组成。我们也把键-值对成为项。例如我们要构建一个电话号码簿，每个人的名字为键，与其对应的电话号码为相应的值。每个键和它的值之间用冒号隔开，项之间用逗号隔开，整个字典用大括号括起来。键可以是任意不可变类型。
``` python
phonebook = {'Alice':'2341','Beth':'3849','Frank':'4854'}
```
- dict 函数
构建字典可以像上述例子一样之间声明，也可以调用dict函数，通过其他映射或者对的序列建立字典。
``` python
>>> items = [('name','Gumby'),('age',42)]
>>> d = dict(items)
>>> d 
{'name': 'Gumby', 'age': 42}
>>> d['name']
'Gumby'
```
dict函数也可以通过关键字参数来创建字典
``` python
>>> d = dict(name = 'Gumby',age = 42)
>>> d 
{'name': 'Gumby', 'age': 42}
```
上面说过键可以为任意不可变的类型，比如为浮点型，字符串或者元组，但是不可以为变量，所以你看dict函数生成的字典的键都自动变成了字符串类型。
- 基本字典操作  
len(d)返回d中项的数量  
d[k]返回关联到键k上的值  
d[k] = v将值v关联到键k上  
del d[k]删除键为k的项
k in d检查d中是否含有键为k的项
``` python
>>> d = dict(name = 'Gumby',age = 42,hobby = 'football',Gender = 'male')
>>> len(d)
4
>>> d['Gender']
'male'
>>> d['hobby'] = 'basketball'
>>> d
{'name': 'Gumby', 'age': 42, 'hobby': 'basketball', 'Gender': 'male'}
>>> del d['age']
{'name': 'Gumby', 'hobby': 'basketball', 'Gender': 'male'}
>>> 'Gender' in d
True
```
即使键起初在字典中并不存在，也可以直接为它赋值，这样字典会自动建立一个新的项。列表就没有这种操作。
``` python
>>> d = dict(name = 'Gumby',age = 42,hobby = 'football',Gender = 'male')
>>> d['home'] = 'NewYork'
>>> d
{'name': 'Gumby', 'age': 42, 'hobby': 'football', 'Gender': 'male', 'home': 'NewYork'}
```
- 字典的格式化字符串  
前面说过使用字符串格式化功能来格式化元组中的值。学了字典之后，可以使用字典来格式化字符串。在每个转换说明符中的%字符后面，可以加上键，后面再跟上其他说明元素
``` python
>>> d = dict(name = 'Gumby',age = 42,hobby = 'football',Gender = 'male')
>>>print("His name is %(name)s" %d)
His name is Gumby
```
### 字典方法
- clear
clear这个方法可以删除字典中所有的项，这个是原地操作，没有返回值
``` python
>>> d = {'name': 'Gumby', 'age': 42}
>>> d.clear()
>>> d
{}
```
- copy  
copy返回一个具有相同键-值对的新字典。copy为浅复制，复制时只会复制父对象，而不会复制对象的内部的子对象。（浅复制: 一级为引用对象，二级为拷贝；原始数据的二级目录改变了，浅复制的数据的二级目录也会改变，但一级目录不变）
``` python
>>> x = {'username':'admin','machines':['foo','bar','baz']}
>>> y = x.copy()
>>> y['username'] = 'mlh'
>>> y['machines'].remove('bar')
>>> y
{'username': 'mlh', 'machines': ['foo','baz']}
>>> x
{'username': 'admin', 'machines': ['foo','baz']}
```
与之相对的是深复制，deepcopy：深拷贝父对象（一级目录），子对象（二级目录）是引用，非拷贝；简单地说就是与最原始的的数据时完全一致的。
``` python
>>> from copy import deepcopy
>>> d = {}
>>> d['name'] = ['Alfred','Bertrand']
>>> c = d.copy()
>>> dc = deepcopy(d)
>>> d['name'].append('Clive')
>>> c
{'names':['Alfred','Bertrand'.'Clive']}
>>> dc
{'names':['Alfred','Bertrand']}
```
- fromkeys  
fromkeys方法使用给定的键建立新的字典，每个键都对应一个默认的值None.
``` python
>>> {}.fromkeys(['name','age'])
{'name': None, 'age': None}
```
- get  
get这个方法是个更宽松的访问字典的方法，一般来说，试图访问字典中不存在的项时会出错，但用get方法不会。
``` python
>>> d = {}
>>> print d['name']
 File "<stdin>", line 1
    print d['name']
          ^
SyntaxError: Missing parentheses in call to 'print'. Did you mean print(d['name'])?
>>> print(d.get('name'))
None
```
还可以用自定义的值来替换None：
``` python
>>> d.get('name','N/A')
'N/A'
```
啊呀呀呀呀我不想写了，我要写下一章
# 条件，循环语句
## 条件和条件语句
下列的值在作为布尔表达式的时候，会被解释器看做假（False）:  
False, None, 0, "", (), {}  
其他的一切都被解释为真，包括特殊值True。
``` python
>>> True
True
>>> False
False
>>> True == 1
True
>>> True + False + 42
43
```
- 条件执行和if语句
如果条件（在if和冒号之间的表达式）判断为真，那么后面的语句块就会被执行，当然如果条件为假，语句块就不会被执行。
``` python
name = raw_input('What is your name?')
if name.endswith('Gumby'):
    print 'Hello,Mr.Gumby'
```
所谓语句块，并非一种语句，语句块是在条件为真时执行或多次执行（循环语句）的一组语句，在代码前放置空格来缩进语句即可创建语句块。块中的每行都应该缩进同样的量。很多语言使用特殊单词或者字符（比如begin或者{}）来表示一个语句块的开始。在Python中，冒号用来标识语句块的开始，块中的每一个语句都是缩进的（缩进量相同）。当退回到和已经闭合的块一样的缩进量时，就表示当前块已经结束了。  
- else语句  
前一节的例子中，如果用户输入了以Gumby作为结尾的名字，那么name.endswith方法就会返回真，使得if进入语句块，打印出问候语，也可以使用else子句增加一种选择。
``` python
name = input('What is your name?')
if name.endswith('Gumby'):
    print ('Hello,Mr.Gumby')
else:
    print ('Hello,stranger')
```
- elif子句  
elif是else if的简写，也是if和else子句的联合使用
``` python
num = input('Enter a number:')
if num > 0:
    print ('The number is positive')
elif num < 0:
    print ('The number is negative')
else:
    print ('The number is zero')
```
- 比较运算符  
不用多说，大家都懂  

|表达式|描述|  
|------|-----|
|x == y    |x等于y|
|x < y      |x小于y|
|x > y      |x大于y|
|x >= y     |x大于等于y|
|x <= y      |x小于等于y|
|x is y      |x和y是同一个对象|
|x is not y   |x和y不是同一个对象|
|x in y      |x是y的成员|
|x not in y      |x是y的成员|
在Python中比较和赋值运算是一样可以连续的，比如0<age<100。  
is运算符是判定同一性而不是相等性的，比如变量x和y分别绑定到两个列表上，尽管这两个列表在数值上可能相等，但x和y并不指向同一个对象：
``` python
>>> x = [1,2,3]
>>> y = [1,2,3]
>>> x is y
False
>>> x == y
True
```
- 布尔运算符  
and,or,not，这几个运算符用起来也很简单
``` python
number = input('Enter a number between 1 and 10:')
if number <= 10 and number >=1:
    print ('Great!')
else :
    print ('Wrong!')
```
- while循环  
``` python
x = 1
while x <= 100:
    print x
    x += 1
```
while后面的表达式为真，就一直循环。
- for循环  
for语句用于遍历序列的元素(如一个字符串,元组或列表)或其他可以迭代的对象
``` python
languages = ["C", "C++", "Perl", "Python"] 
for x in languages:
    print (x)
C
C++
Perl
Python
```
``` python
>>> range(0,10)
[0,1,2,3,4,5,6,7,8,9]
for number in range(0,10)
    print()
```
### 一些迭代工具
1. 并行迭代  
如果有两个序列
``` python
names = ['anne','beth','george','damon']
ages = [12,45,32,102]
```
如果要打印名字和对应的年龄，可以像下面这样做：
``` python
for i in range(len(names)):
    print (names[i], 'is',ages[i],'years old')
#以下是运行结果
anne is 12 years old
beth is 45 years old
george is 32 years old
damon is 102 years old
```
print在打印时，用逗号可以把几个字符串连起来打印  
zip函数可以把两个序列“压缩”在一起，然后返回一个元组的列表。在python 3.0中zip()是可迭代对象，使用时必须将其包含在一个list中，方便一次性显示出所有结果
``` python
>>> list(zip(names,ages))
[('anne', 12), ('beth', 45), ('george', 32), ('damon', 102)]
```
``` python
names = ['anne','beth','george','damon']
ages = [12,45,32,102]
for i in range(len(names)):
    print ('%s is %s years old'%list(zip(names,ages))[i])
```
2. 按索引迭代
这个我没看懂，觉得没啥用

- break
``` python
from math import sqrt
for n in range(99,0,-1)
    root = sqrt(n)
    if root == int(root):
        print n
        break
```
# 函数
## 创建函数
使用def语句定义即可：
``` python
def hello(name):
    return 'Hello,'+name+'!'
    #几个字符串可以通过+号连成一个字符串，下面是运行
>>> print hello('world')
Hello,world!
```
下面写个小程序计算斐波那契数列（任一个数字都是前两数之和的数字序列）：
``` python
def fibs(num):
    result = [0,1]
    for i in range(num-2)
        result.append(result[-2]+result[-1])
    return result
#下面是运行情况
>>> fibs(10)
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```
## 文档化函数
可以在函数下面写一个字符串，用来描述函数的功能：
``` python
def square():
    'Calculate the suqare of the number x'
    return x*x
```
文档字符串可以通过如下方式访问
``` python
>>> suqare._doc_
'Calculate the suqare of the number x'
#或者使用help函数
>>> help(square)
Help on function square in module __main__:

square()
    Calculate the suqare of the number x
```
## 函数参数
观察下面的例子：
``` python
def change(n):
    n = 'Mr.liu'
    return
name = 'wang'
change(name)
>>> name
'wang'
```
为什么调用了函数名字还是没有改成'Mr.liu'呢，在change函数内，参数n获得了新值，但它没有影响到name变量，n实际上是个完全不同的变量，具体的工作方式类似于下面这样：
``` python
>>> name = 'wang'
>>> n = name
>>> n = 'Mr.liu'
>>> name
'wang'
```
写在def语句中函数名后面的变量通常叫做函数的形参，而调用函数时提供的值是实参，或者参数。  
再看下面的例子：
``` python
def change(n):
    n[0] = 'Mr.liu'
    return
name = ['wang','zhang']
change(name)
#下面是运行结果
>>> name
['Mr.liu', 'zhang']
```
我们同样对上面的过程做个解释，其工作方式类似于下面这样：
``` python
>>> name = ['wang','zhang']
>>> n = name
>>> n[0] = 'Mr.liu'
>>> name
['Mr.liu', 'zhang']
```

## 小试牛刀

